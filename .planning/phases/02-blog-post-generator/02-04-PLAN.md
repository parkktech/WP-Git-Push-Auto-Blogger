---
phase: 02-blog-post-generator
plan: 04
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
  - 02-03
files_modified:
  - scripts/generate-blog-post.js
autonomous: true
requirements:
  - NOTF-01
  - NOTF-02

user_setup:
  - service: telegram
    why: "Pipeline completion notification"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Telegram BotFather -> /newbot command -> copy the token (https://t.me/BotFather)"
      - name: TELEGRAM_CHAT_ID
        source: "Send a message to your bot, then GET https://api.telegram.org/bot{TOKEN}/getUpdates to find your chat_id"
  - service: anthropic
    why: "Claude API for commit evaluation and blog post generation"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "Anthropic Console -> API Keys (https://console.anthropic.com/settings/keys)"
  - service: project_registry
    why: "Portfolio framing metadata for generated posts"
    env_vars:
      - name: PROJECT_NAME
        source: "Set to the project name (e.g., 'Parkk Blog Engine')"
      - name: PROJECT_URL
        source: "Set to the project URL (e.g., 'https://github.com/parkktechnology/parkk-blog-engine')"
      - name: PROJECT_DESCRIPTION
        source: "Set to a one-line project description"
  - service: screenshot_config
    why: "Optional staging URL configuration for Puppeteer screenshots"
    env_vars:
      - name: SCREENSHOT_URLS
        source: "Comma-separated list of staging URLs to screenshot (optional — leave empty to use stock images only)"

must_haves:
  truths:
    - "Running `node scripts/generate-blog-post.js` with COMMIT_MESSAGE and COMMIT_DIFF env vars executes the full pipeline: skip check -> evaluation -> screenshots -> stock images -> generation -> media upload -> post creation -> notification"
    - "When commit matches skip patterns, script exits cleanly with exit code 0 and message 'Skipping commit'"
    - "When worthiness score is below threshold, script exits cleanly with exit code 0 and message including the score"
    - "When all external services are configured, the script creates a WordPress draft and sends a Telegram notification"
    - "Telegram notification includes post title, worthiness score, draft status, and WordPress draft link"
    - "Telegram notification failure does not cause the pipeline to fail — it is non-fatal"
    - "When TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID is not set, notification is skipped silently"
    - "Stock images are always searched regardless of screenshot availability (supplement, not just fallback per locked decision)"
    - "Unsplash attribution HTML is appended to post htmlContent before WordPress upload"
  artifacts:
    - path: "scripts/generate-blog-post.js"
      provides: "Main pipeline orchestrator — entry point for the blog post generator"
      min_lines: 80
  key_links:
    - from: "scripts/generate-blog-post.js"
      to: "scripts/evaluate-commit.js"
      via: "require('./evaluate-commit')"
      pattern: "require\\('./evaluate-commit'\\)"
    - from: "scripts/generate-blog-post.js"
      to: "scripts/media-pipeline.js"
      via: "require('./media-pipeline')"
      pattern: "require\\('./media-pipeline'\\)"
    - from: "scripts/generate-blog-post.js"
      to: "scripts/wp-client.js"
      via: "require('./wp-client')"
      pattern: "require\\('./wp-client'\\)"
    - from: "scripts/generate-blog-post.js"
      to: "Telegram Bot API"
      via: "native fetch() to api.telegram.org"
      pattern: "api\\.telegram\\.org"
---

<objective>
Build the main pipeline orchestrator that wires all modules together and adds Telegram notifications.

Purpose: This is the entry point script that GitHub Actions (Phase 3) will call. It orchestrates the full commit-to-WordPress-draft pipeline by importing the three helper modules (evaluate-commit, media-pipeline, wp-client) and running them in the correct sequence. Telegram notification is the final step — non-fatal, never blocks the pipeline.

Output: `scripts/generate-blog-post.js` — the complete pipeline entry point.
</objective>

<execution_context>
@/home/jratz/.claude/get-shit-done/workflows/execute-plan.md
@/home/jratz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-blog-post-generator/02-RESEARCH.md
@.planning/phases/02-blog-post-generator/02-01-SUMMARY.md
@.planning/phases/02-blog-post-generator/02-02-SUMMARY.md
@.planning/phases/02-blog-post-generator/02-03-SUMMARY.md
@scripts/brand-voice.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generate-blog-post.js main orchestrator wiring all modules</name>
  <files>scripts/generate-blog-post.js</files>
  <action>
Create `scripts/generate-blog-post.js` as a CommonJS module and the pipeline entry point.

**Imports:**

```javascript
'use strict';
const { shouldSkipCommit, evaluateWorthiness, generateBlogPost, WORTHINESS_THRESHOLD } = require('./evaluate-commit');
const { captureScreenshots, searchUnsplash } = require('./media-pipeline');
const { uploadMedia, createWordPressPost } = require('./wp-client');
```

**Main function:**

```javascript
async function main() { ... }
```

Read inputs from environment:
- `COMMIT_MESSAGE` — the git commit message (required)
- `COMMIT_DIFF` — the git diff content (required)
- `COMMIT_AUTHOR` — the commit author login (optional, for dependabot check)
- `SCREENSHOT_URLS` — comma-separated URLs for Puppeteer (optional)

**Pipeline steps (sequential):**

**Step 1 — Skip check:**
- Call `shouldSkipCommit(commitMessage, commitAuthor)`
- If true: `console.log('Skipping commit: matches skip pattern')` and `process.exit(0)`

**Step 2 — Worthiness evaluation:**
- Call `const evaluation = await evaluateWorthiness(commitMessage, diff)`
- Log: `console.log(\`Worthiness: ${evaluation.score}/10 — ${evaluation.topic_summary}\`)`
- If `evaluation.score < WORTHINESS_THRESHOLD`: `console.log(\`Skipping commit: worthiness score ${evaluation.score} below threshold ${WORTHINESS_THRESHOLD}\`)` and `process.exit(0)`

**Step 3 — Media acquisition (parallel):**
- Parse SCREENSHOT_URLS: `const urls = process.env.SCREENSHOT_URLS ? process.env.SCREENSHOT_URLS.split(',').map(u => u.trim()).filter(Boolean) : []`
- Run screenshots and stock images in parallel:
  ```javascript
  const [screenshots, stockImages] = await Promise.all([
    captureScreenshots(urls),
    searchUnsplash(evaluation.topic_summary, 3)  // always search — supplement, not just fallback
  ]);
  ```
- Per locked decision: "Stock images used alongside screenshots for visual variety — always supplement, not just fallback"

**Step 4 — Blog post generation:**
- Call `const post = await generateBlogPost(commitMessage, diff, evaluation, screenshots)`
- The screenshots are passed as image blocks for Claude's vision

**Step 5 — Append Unsplash attribution to post content:**
- If stockImages has items, append attribution HTML to `post.htmlContent`:
  ```javascript
  if (stockImages.length > 0) {
    const attributionBlock = stockImages.map(img => `<p class="photo-credit">${img.attribution}</p>`).join('\n');
    post.htmlContent += `\n\n<!-- Unsplash Attribution -->\n${attributionBlock}`;
  }
  ```

**Step 6 — Upload media to WordPress:**
- Upload all images (screenshots + stock images) to WordPress media library:
  ```javascript
  const allImages = [
    ...screenshots.map((s, i) => ({ buffer: s.buffer, filename: `screenshot-${i + 1}.png`, mimeType: 'image/png' })),
    ...stockImages.map(s => ({ buffer: s.buffer, filename: s.filename, mimeType: s.mimeType }))
  ];

  const mediaIds = [];
  for (const img of allImages) {
    try {
      const media = await uploadMedia(img.buffer, img.filename, img.mimeType);
      mediaIds.push(media.id);
      console.log(`Uploaded media: ${img.filename} -> ID ${media.id}`);
    } catch (err) {
      console.warn(`Media upload failed for ${img.filename}: ${err.message}`);
    }
  }
  ```

**Step 7 — Create WordPress post:**
- Call `const wpPost = await createWordPressPost(post, mediaIds)`
- Log: `console.log(\`Post created: ${wpPost.link}\`)`

**Step 8 — Send Telegram notification** (defined inline — see Task 2 for the function):
- Call `await sendTelegramNotification(wpPost.link, evaluation.score, post.title)`

**Step 9 — Output summary:**
- Log JSON summary to stdout for GitHub Actions output:
  ```javascript
  console.log(JSON.stringify({
    postId: wpPost.id,
    postUrl: wpPost.link,
    worthinessScore: evaluation.score,
    title: post.title,
    status: wpPost.status
  }));
  ```

**Entry point:**

```javascript
main().catch(err => {
  console.error('Pipeline failed:', err.message);
  process.exit(1);
});
```

Do NOT add the Telegram function yet — Task 2 will add it. For now, add a stub function above `main()` that logs "Telegram: not yet implemented" and returns immediately: `async function sendTelegramNotification() { console.log('Telegram: not yet implemented'); }`. The file must be syntactically valid and the stub must prevent ReferenceError when main() calls sendTelegramNotification().
  </action>
  <verify>
    <automated>node -e "try { require('./scripts/generate-blog-post'); console.log('generate-blog-post.js loads without syntax errors'); } catch(e) { if (e.message.includes('Cannot find module')) { console.log('Module syntax is valid (dependency import error expected without prior plan modules)'); } else { throw e; } }"</automated>
    <manual>Review the pipeline step sequence: skip check -> evaluation -> media (parallel) -> generation -> attribution append -> media upload -> post creation -> notification -> summary output</manual>
  </verify>
  <done>generate-blog-post.js created as the main pipeline entry point. Imports evaluate-commit, media-pipeline, and wp-client modules. Runs 9-step pipeline: skip check, worthiness evaluation, parallel media acquisition, blog post generation, attribution append, media upload, WordPress post creation, Telegram notification, summary output. Exit 0 on skip/low-score. Exit 1 on pipeline failure.</done>
</task>

<task type="auto">
  <name>Task 2: Add Telegram notification function with HTML formatting</name>
  <files>scripts/generate-blog-post.js</files>
  <action>
Add the `sendTelegramNotification()` function to `scripts/generate-blog-post.js` (above the `main()` function).

**Telegram notification function:**

```javascript
async function sendTelegramNotification(postUrl, score, postTitle) {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  const chatId = process.env.TELEGRAM_CHAT_ID;

  if (!token || !chatId) {
    console.log('Telegram not configured — skipping notification');
    return;
  }

  // Escape HTML special characters in user-generated text (see Pitfall 6 from research)
  const safeTitle = postTitle
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  const message = [
    '<b>New blog post draft created</b>',
    '',
    `<b>Title:</b> ${safeTitle}`,
    `<b>Worthiness score:</b> ${score}/10`,
    `<b>Status:</b> Draft`,
    '',
    `<a href="${postUrl}">View draft in WordPress</a>`
  ].join('\n');

  try {
    const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        text: message,
        parse_mode: 'HTML',
        disable_web_page_preview: false
      })
    });

    if (!response.ok) {
      console.error(`Telegram notification failed: ${response.status} ${await response.text()}`);
    } else {
      console.log('Telegram notification sent');
    }
  } catch (err) {
    // Non-fatal — pipeline already succeeded at this point
    console.error('Telegram notification error (non-fatal):', err.message);
  }
}
```

Key points:
- **Non-fatal:** Entire function is wrapped in try/catch. Telegram failure NEVER causes pipeline to exit with error. The post is already created in WordPress at this point.
- **HTML escaping:** Post title is escaped for Telegram HTML parse mode (Pitfall 6 from research). Score and URL are safe (integer and URL respectively).
- **Graceful skip:** If TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID is missing, function logs and returns without error.
- **Content:** Includes post title, worthiness score (X/10), draft status, and clickable WordPress link.
- Uses native `fetch()` — no telegram library (per research: "Literally one HTTP call; a library is overkill").

Remove any placeholder/stub for sendTelegramNotification from Task 1 and replace with this real implementation.
  </action>
  <verify>
    <automated>node -e "const src = require('fs').readFileSync('./scripts/generate-blog-post.js', 'utf8'); console.assert(src.includes('sendTelegramNotification'), 'sendTelegramNotification function exists'); console.assert(src.includes('api.telegram.org'), 'Telegram API URL present'); console.assert(src.includes('parse_mode'), 'HTML parse mode configured'); console.assert(src.includes('&amp;'), 'HTML escaping for ampersand'); console.assert(src.includes('Non-fatal'), 'Non-fatal comment present'); console.log('Telegram function verified in source')"</automated>
    <manual>Verify the notification message includes all required fields: title, worthiness score, status, and post link</manual>
  </verify>
  <done>sendTelegramNotification function implemented with HTML escaping, non-fatal error handling, and graceful skip when credentials are missing. Message includes post title, worthiness score, draft status, and WordPress link. Uses native fetch() to Telegram Bot API.</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end dry-run verification of module wiring</name>
  <files>scripts/generate-blog-post.js</files>
  <action>
**Pre-condition for end-to-end testing:** The `wordpress-plugin/parkk-seo-meta-bridge.php` stub (Plan 02-05) must be installed and activated on the WordPress site before running any end-to-end integration tests. Without it, SEO meta fields are silently dropped by WordPress REST API and ROADMAP success criterion 4 cannot be satisfied.

Verify the full module wiring by running a dry-run import test that:

1. **Loads all modules without error:**
   ```javascript
   const evalMod = require('./scripts/evaluate-commit');
   const mediaMod = require('./scripts/media-pipeline');
   const wpMod = require('./scripts/wp-client');
   ```

2. **Verifies all expected exports exist:**
   - evaluate-commit: shouldSkipCommit (function), evaluateWorthiness (function), generateBlogPost (function), WORTHINESS_THRESHOLD (number === 7), POST_JSON_SCHEMA (object)
   - media-pipeline: captureScreenshots (function), searchUnsplash (function)
   - wp-client: uploadMedia (function), resolveCategoryIds (function), resolveOrCreateTagIds (function), createWordPressPost (function)

3. **Runs skip pattern smoke test:**
   - shouldSkipCommit('chore: bump version') === true
   - shouldSkipCommit('Merge pull request #99') === true
   - shouldSkipCommit('feat: add blog pipeline') === false
   - shouldSkipCommit('test update [skip-blog]') === true
   - shouldSkipCommit('fix: auth', 'dependabot[bot]') === true

4. **Verifies generate-blog-post.js loads** (syntax check — will not run pipeline since env vars are missing):
   - The file should be parseable JavaScript
   - Contains references to all three imported modules

5. **Verifies brand-voice.js integration:**
   - evaluate-commit.js imports brand-voice (check source for require('./brand-voice'))

This is a verification-only task. Do NOT modify any files. Run the assertions as a node -e command.
  </action>
  <verify>
    <automated>node -e "
const assert = require('assert');
// 1. Load all modules
const evalMod = require('./scripts/evaluate-commit');
const mediaMod = require('./scripts/media-pipeline');
const wpMod = require('./scripts/wp-client');
// 2. Verify exports
assert.strictEqual(typeof evalMod.shouldSkipCommit, 'function', 'shouldSkipCommit');
assert.strictEqual(typeof evalMod.evaluateWorthiness, 'function', 'evaluateWorthiness');
assert.strictEqual(typeof evalMod.generateBlogPost, 'function', 'generateBlogPost');
assert.strictEqual(evalMod.WORTHINESS_THRESHOLD, 7, 'WORTHINESS_THRESHOLD');
assert.strictEqual(typeof evalMod.POST_JSON_SCHEMA, 'object', 'POST_JSON_SCHEMA');
assert.strictEqual(typeof mediaMod.captureScreenshots, 'function', 'captureScreenshots');
assert.strictEqual(typeof mediaMod.searchUnsplash, 'function', 'searchUnsplash');
assert.strictEqual(typeof wpMod.uploadMedia, 'function', 'uploadMedia');
assert.strictEqual(typeof wpMod.resolveCategoryIds, 'function', 'resolveCategoryIds');
assert.strictEqual(typeof wpMod.resolveOrCreateTagIds, 'function', 'resolveOrCreateTagIds');
assert.strictEqual(typeof wpMod.createWordPressPost, 'function', 'createWordPressPost');
// 3. Skip pattern smoke test
assert.strictEqual(evalMod.shouldSkipCommit('chore: bump version', null), true);
assert.strictEqual(evalMod.shouldSkipCommit('Merge pull request #99', null), true);
assert.strictEqual(evalMod.shouldSkipCommit('feat: add blog pipeline', null), false);
assert.strictEqual(evalMod.shouldSkipCommit('test update [skip-blog]', null), true);
assert.strictEqual(evalMod.shouldSkipCommit('fix: auth', 'dependabot[bot]'), true);
// 4. Source check for wiring
const fs = require('fs');
const mainSrc = fs.readFileSync('./scripts/generate-blog-post.js', 'utf8');
assert(mainSrc.includes(\"require('./evaluate-commit')\"), 'imports evaluate-commit');
assert(mainSrc.includes(\"require('./media-pipeline')\"), 'imports media-pipeline');
assert(mainSrc.includes(\"require('./wp-client')\"), 'imports wp-client');
// 5. Brand voice integration
const evalSrc = fs.readFileSync('./scripts/evaluate-commit.js', 'utf8');
assert(evalSrc.includes(\"require('./brand-voice')\"), 'evaluate-commit imports brand-voice');
console.log('ALL WIRING CHECKS PASSED — 16 assertions');
"</automated>
  </verify>
  <done>All 4 modules load without errors. All 11 function exports verified. 5 skip pattern assertions pass. Main script imports all 3 helper modules. evaluate-commit imports brand-voice. Complete module wiring verified.</done>
</task>

</tasks>

<verification>
1. `node scripts/generate-blog-post.js` with no env vars fails gracefully (missing COMMIT_MESSAGE)
2. All 4 source files exist: generate-blog-post.js, evaluate-commit.js, media-pipeline.js, wp-client.js
3. Module dependency chain: generate-blog-post -> evaluate-commit -> brand-voice, generate-blog-post -> media-pipeline, generate-blog-post -> wp-client
4. Telegram function handles missing credentials gracefully
5. Stock images are always searched (not just fallback) — parallel with screenshots
6. Unsplash attribution HTML appended to post content before WordPress upload
7. Pipeline exits cleanly (code 0) on skip patterns and low worthiness scores
</verification>

<success_criteria>
- `scripts/generate-blog-post.js` exists as the complete pipeline entry point
- Pipeline runs 9 sequential steps: skip -> evaluate -> media (parallel) -> generate -> attribution -> upload -> post -> notify -> summary
- Telegram notification includes title, score, status, and link
- Telegram failure is non-fatal (try/catch, never causes exit 1)
- Missing Telegram credentials cause silent skip
- Stock images always searched alongside screenshots (supplement, not fallback)
- Unsplash attribution appended to post content
- All module imports verified working
- Module follows CommonJS pattern established in Phase 1
</success_criteria>

<output>
After completion, create `.planning/phases/02-blog-post-generator/02-04-SUMMARY.md`
</output>
