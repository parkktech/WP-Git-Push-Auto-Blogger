---
phase: 02-blog-post-generator
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/wp-client.js
autonomous: true
requirements:
  - PUBL-01
  - PUBL-02
  - PUBL-03
  - PUBL-04
  - PUBL-06
  - PUBL-07

user_setup:
  - service: wordpress
    why: "WordPress REST API for post creation and media upload"
    env_vars:
      - name: WP_API_URL
        source: "Your WordPress site REST API base URL (e.g., https://parkktech.com/wp-json)"
      - name: WP_USER
        source: "WordPress username with publish_posts and upload_files capabilities"
      - name: WP_APP_PASSWORD
        source: "WordPress Admin -> Users -> Your User -> Application Passwords -> Add New"
      - name: WORDPRESS_SEO_PLUGIN
        source: "Set to 'yoast' or 'rankmath' depending on which is installed (optional — writes both if unset)"

must_haves:
  truths:
    - "uploadMedia() POSTs binary image data to /wp/v2/media and returns { id, url }"
    - "resolveCategoryIds() resolves category slug strings to WordPress integer IDs via REST API, creating categories that don't exist"
    - "resolveOrCreateTagIds() resolves tag strings to WordPress integer IDs via REST API, creating tags that don't exist"
    - "createWordPressPost() creates a post via POST /wp/v2/posts with title, slug, content, excerpt, status, categories, tags, featured_media, and meta fields"
    - "Post status defaults to 'draft' and is overridable via PUBLISH_STATUS env var"
    - "SEO meta fields are written for Yoast (_yoast_wpseo_metadesc, _yoast_wpseo_focuskw, _yoast_wpseo_title) when WORDPRESS_SEO_PLUGIN is 'yoast'"
    - "SEO meta fields are written for RankMath (rank_math_focus_keyword, rank_math_description, rank_math_title) when WORDPRESS_SEO_PLUGIN is 'rankmath'"
    - "When WORDPRESS_SEO_PLUGIN is unset or 'both', all 6 SEO meta fields are written (WordPress silently drops unregistered ones)"
    - "Featured image is set via featured_media field using the first uploaded media ID"
  artifacts:
    - path: "scripts/wp-client.js"
      provides: "WordPress REST API client functions"
      exports: ["uploadMedia", "resolveCategoryIds", "resolveOrCreateTagIds", "createWordPressPost"]
  key_links:
    - from: "scripts/wp-client.js"
      to: "WordPress REST API"
      via: "native fetch() to WP_API_URL/wp/v2/*"
      pattern: "WP_API_URL.*wp/v2"
    - from: "scripts/wp-client.js"
      to: "scripts/generate-blog-post.js (Plan 04)"
      via: "module.exports consumed by main orchestrator"
      pattern: "module\\.exports"
---

<objective>
Build the WordPress REST API client module that handles media uploads, category/tag resolution, and post creation with SEO meta.

Purpose: This module encapsulates all WordPress interactions — uploading images, resolving/creating taxonomy terms, and creating the final post with SEO fields for Yoast or RankMath. Separating WordPress API calls from content generation and media acquisition keeps each module focused.

Output: `scripts/wp-client.js` exporting `uploadMedia()`, `resolveCategoryIds()`, `resolveOrCreateTagIds()`, and `createWordPressPost()` functions.
</objective>

<execution_context>
@/home/jratz/.claude/get-shit-done/workflows/execute-plan.md
@/home/jratz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-blog-post-generator/02-RESEARCH.md
@scripts/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create wp-client.js with media upload and taxonomy resolution</name>
  <files>scripts/wp-client.js</files>
  <action>
Create `scripts/wp-client.js` as a CommonJS module.

**Shared auth helper (module-level):**

```javascript
function getAuth() {
  return Buffer.from(`${process.env.WP_USER}:${process.env.WP_APP_PASSWORD}`).toString('base64');
}
function getApiUrl() {
  return process.env.WP_API_URL;  // e.g., https://parkktech.com/wp-json
}
```

**Part A — Media upload function:**

```javascript
async function uploadMedia(imageBuffer, filename, mimeType = 'image/png') { ... }
```

- POST to `${getApiUrl()}/wp/v2/media`
- Headers: `Authorization: Basic ${getAuth()}`, `Content-Type: ${mimeType}`, `Content-Disposition: attachment; filename="${filename}"`
- Body: raw `imageBuffer` (Buffer)
- Use native `fetch()` — do NOT use form-data library for this (the WordPress media endpoint accepts raw binary with Content-Type header; form-data is only needed for multipart which is not required here)
- On success: return `{ id: media.id, url: media.source_url }`
- On failure: throw descriptive error with HTTP status and response body

**Part B — Category resolution function:**

```javascript
async function resolveCategoryIds(categorySlugs) { ... }
```

- For each slug in `categorySlugs`:
  - GET `${getApiUrl()}/wp/v2/categories?slug=${encodeURIComponent(slug)}`
  - If found (array length > 0): use `existing[0].id`
  - If not found: POST `${getApiUrl()}/wp/v2/categories` with `{ name: slugToName(slug), slug }` (convert slug to title case for name: 'web-development' -> 'Web Development')
  - Push the integer ID to results
- Return array of integer IDs
- WordPress REST API requires integer IDs for categories — this is the resolution layer (see Pitfall 3 from research)

**Part C — Tag resolution function:**

```javascript
async function resolveOrCreateTagIds(tagStrings) { ... }
```

- For each tag string:
  - Generate slug: `tag.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')`
  - GET `${getApiUrl()}/wp/v2/tags?slug=${slug}`
  - If found: use `existing[0].id`
  - If not found: POST `${getApiUrl()}/wp/v2/tags` with `{ name: tag, slug }`
  - Push the integer ID to results
- Return array of integer IDs

Add a helper `slugToName(slug)` that converts 'web-development' to 'Web Development' (split on '-', capitalize each word, join with space).

Export: `module.exports = { uploadMedia, resolveCategoryIds, resolveOrCreateTagIds }` — do NOT add createWordPressPost yet (Task 2).
  </action>
  <verify>
    <automated>node -e "const m = require('./scripts/wp-client'); console.assert(typeof m.uploadMedia === 'function'); console.assert(typeof m.resolveCategoryIds === 'function'); console.assert(typeof m.resolveOrCreateTagIds === 'function'); console.log('All 3 WordPress helper functions exported')"</automated>
    <manual>Verify that uploadMedia uses raw binary POST (not form-data multipart), and that category/tag resolution correctly handles both existing and new terms</manual>
  </verify>
  <done>uploadMedia, resolveCategoryIds, and resolveOrCreateTagIds all exported. Media upload uses raw binary POST with Content-Disposition header. Category resolution converts slugs to IDs via REST API, creating missing categories. Tag resolution generates slugs from tag strings and creates missing tags. All use native fetch().</done>
</task>

<task type="auto">
  <name>Task 2: Add WordPress post creation with SEO meta field support</name>
  <files>scripts/wp-client.js</files>
  <action>
Add `createWordPressPost()` to the existing `scripts/wp-client.js`.

**Post creation function:**

```javascript
async function createWordPressPost(post, mediaIds, seoPlugin) { ... }
```

Parameters:
- `post`: object with `title`, `slug`, `htmlContent`, `excerpt`, `seoTitle`, `metaDescription`, `focusKeyword`, `secondaryKeywords`, `categories` (slug strings), `tags` (tag strings)
- `mediaIds`: array of WordPress media IDs (integers) — first one becomes featured image
- `seoPlugin`: string — `'yoast'`, `'rankmath'`, or `'both'` (default)

Implementation:
1. **Resolve taxonomy IDs** (call the functions from Task 1):
   ```javascript
   const categoryIds = await resolveCategoryIds(post.categories);
   const tagIds = await resolveOrCreateTagIds(post.tags);
   ```

2. **Build SEO meta object** based on `seoPlugin` parameter:
   ```javascript
   const meta = {};
   const plugin = seoPlugin || process.env.WORDPRESS_SEO_PLUGIN || 'both';

   if (plugin === 'yoast' || plugin === 'both') {
     meta['_yoast_wpseo_metadesc'] = post.metaDescription;
     meta['_yoast_wpseo_focuskw'] = post.focusKeyword;
     meta['_yoast_wpseo_title'] = post.seoTitle;
   }
   if (plugin === 'rankmath' || plugin === 'both') {
     meta['rank_math_focus_keyword'] = post.focusKeyword;
     meta['rank_math_description'] = post.metaDescription;
     meta['rank_math_title'] = post.seoTitle;
   }
   ```

3. **Build post payload:**
   ```javascript
   const payload = {
     title: post.title,
     slug: post.slug,
     content: post.htmlContent,
     excerpt: post.excerpt,
     status: process.env.PUBLISH_STATUS || 'draft',
     categories: categoryIds,
     tags: tagIds,
     featured_media: mediaIds.length > 0 ? mediaIds[0] : 0,
     meta
   };
   ```

4. **POST to WordPress:**
   - POST `${getApiUrl()}/wp/v2/posts`
   - Headers: `Authorization: Basic ${getAuth()}`, `Content-Type: application/json`
   - Body: `JSON.stringify(payload)`
   - On success: return the full response JSON (contains `id`, `link`, `status`, etc.)
   - On failure: throw descriptive error with HTTP status and response body
   - Log: `console.log(\`WordPress post created: ${result.link} (status: ${result.status})\`)`

**Update module.exports** to include `createWordPressPost`.

Note on SEO meta: Research confirms WordPress silently drops unregistered meta fields (no error). Writing both Yoast and RankMath fields when `plugin === 'both'` is safe — only the registered fields will persist. **Pre-condition:** The `wordpress-plugin/parkk-seo-meta-bridge.php` stub (Plan 02-05) must be installed and activated on the WordPress site for SEO meta fields to persist via REST API. Without it, all 6 fields are silently dropped. This stub will later be absorbed into the full Phase 4 WordPress plugin.
  </action>
  <verify>
    <automated>node -e "const m = require('./scripts/wp-client'); console.assert(typeof m.createWordPressPost === 'function'); console.assert(typeof m.uploadMedia === 'function'); console.assert(typeof m.resolveCategoryIds === 'function'); console.assert(typeof m.resolveOrCreateTagIds === 'function'); console.log('All 4 WordPress client functions exported')"</automated>
    <manual>Verify that SEO meta object correctly maps fields for both Yoast and RankMath, and that PUBLISH_STATUS defaults to 'draft'</manual>
  </verify>
  <done>createWordPressPost function exported. Creates WordPress post with all fields: title, slug, content, excerpt, status (defaults to draft), categories (resolved to IDs), tags (resolved to IDs), featured_media (first media ID), and meta (SEO fields for Yoast, RankMath, or both). Returns full WordPress response JSON including post link.</done>
</task>

</tasks>

<verification>
1. `require('./scripts/wp-client')` loads without error
2. All 4 functions exported: uploadMedia, resolveCategoryIds, resolveOrCreateTagIds, createWordPressPost
3. Media upload uses raw binary POST with correct headers (not multipart form-data)
4. Category/tag resolution handles both existing and new terms
5. Post creation includes all required fields: title, slug, content, excerpt, status, categories, tags, featured_media, meta
6. SEO meta supports yoast, rankmath, and both modes
7. Post status defaults to 'draft' via PUBLISH_STATUS env var
8. All API calls use native fetch() and Basic auth from WP_USER + WP_APP_PASSWORD
</verification>

<success_criteria>
- `scripts/wp-client.js` exists and exports uploadMedia, resolveCategoryIds, resolveOrCreateTagIds, createWordPressPost
- Category slugs are resolved to integer IDs (not passed as strings)
- Tags are resolved/created with proper slugification
- SEO meta fields cover both Yoast and RankMath with correct field names
- Post defaults to draft status
- Featured image set from first media ID
- All functions use native fetch() with Basic auth
- Module follows CommonJS pattern established in Phase 1
</success_criteria>

<output>
After completion, create `.planning/phases/02-blog-post-generator/02-03-SUMMARY.md`
</output>
